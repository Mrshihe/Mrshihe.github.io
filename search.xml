<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AMD/CMD/CommonJs/ES6对比</title>
    <url>/2018/03/08/AMD-CMD-CommonJs-ES6%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>AMD,CMD,CommonJs,ES6均是javascript模块化的规范</p>
<a id="more"></a>
<p>一. CommonJs规范<br>CommonJs是同步加载模块,在浏览器端不适用,主要用于服务端,如NodeJs<br>CommonJs暴露了两个对外API,用来定义模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require() &#x2F;&#x2F; 同步引入模块</span><br><span class="line">module.exports &#x2F; exports &#x2F;&#x2F; 导出需要暴露的接口</span><br></pre></td></tr></table></figure>
<p>二. AMD规范<br>AMD规范用于异步加载模块,允许指定回调函数,用于浏览器端,如require.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require([module], callback) &#x2F;&#x2F; 引入模块</span><br><span class="line">define(id, [depends], callback) &#x2F;&#x2F; 定义模块</span><br></pre></td></tr></table></figure>
<p>AMD使用时我们需要提前加载所有依赖<br>三. CMD规范<br>CMD和AMD规范类似,CMD推荐依赖就近,按需加载,用于浏览器端,如sea.js<br>四. ES6规范<br>ES6用export 导出模块, 用import导入模块<br>ES6模块自动采用严格模式,无需定义”use strict”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function add() &#123;&#125;  &#x2F;&#x2F; 为模块指定一个默认输出, 一个模块下只能存在一个 export default</span><br><span class="line">import [anyname] from &#39;&#39; &#x2F;&#x2F; import导出带有default的模块时, 名字可以不对应, 不用加&#123;&#125;</span><br><span class="line"></span><br><span class="line">function add() &#123;&#125;</span><br><span class="line">export &#123;</span><br><span class="line">  add as up &#x2F;&#x2F; export可以用as关键字重命名add方法的对外接口名</span><br><span class="line">&#125;</span><br><span class="line">import &#123; up &#125; from &#39;&#39; &#x2F;&#x2F;此时导出的up其实就是定义的add方法</span><br><span class="line">import &#123; up as up_new &#125; from &#39;&#39; &#x2F;&#x2F;import也可以用as关键字重命名方法 此时up_new 就是定义的的add()方法</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js常用小功能</title>
    <url>/2019/06/17/js%E5%B8%B8%E7%94%A8%E5%B0%8F%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>记录一下可以用到项目里的小技巧</p>
<a id="more"></a>
<p>一、钱数的千分位分隔符(1,234.89)<br>1.正则 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&quot;1234,89&quot;).replace(&#x2F;(\d)(?&#x3D;(\d&#123;3&#125;)+\.)&#x2F;g, &#39;$1,&#39;)</span><br></pre></td></tr></table></figure>
<p>?=n 匹配其后紧跟n的字符串  n+ 匹配1到多次包含n的字符串</p>
<p>2.函数实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function moneyCut(number) &#123;</span><br><span class="line">  const decimal &#x3D; String(number).split(&#39;.&#39;)[1] || &#39;&#39; &#x2F;&#x2F;如果有小数,先保留小数部分</span><br><span class="line">  let resArr &#x3D; []</span><br><span class="line">  let reverseArr &#x3D; String(number).split(&#39;.&#39;)[0].split(&#39;&#39;).reverse() &#x2F;&#x2F;将整数部分转成数组并倒序</span><br><span class="line">  for(let i&#x3D;0; i&lt;reverseArr.length; i++)&#123;</span><br><span class="line">    resArr.push(reverseArr[i])</span><br><span class="line">    if((i+1)%3&#x3D;&#x3D;&#x3D;0 &amp;&amp; i !&#x3D; reverseArr.length-1)&#123; &#x2F;&#x2F;处理满三位数和边界情况</span><br><span class="line">      resArr.push(&#39;,&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  const resStr &#x3D; resArr.reverse().join(&#39;&#39;) &#x2F;&#x2F; 将处理后的重新转换成字符串</span><br><span class="line">  return decimal ? resStr+&#39;.&#39;+decimal : resStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+gitPages搭建简单博客</title>
    <url>/2018/01/26/hexo-gitPages%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="基于hexo和gitPages搭建的博客"><a href="#基于hexo和gitPages搭建的博客" class="headerlink" title="基于hexo和gitPages搭建的博客"></a>基于hexo和gitPages搭建的博客</h3><p>只是用来记录一些工作心得，所以怎么简单怎么来</p>
<a id="more"></a>
<h3 id="hexo-常用命令"><a href="#hexo-常用命令" class="headerlink" title="hexo 常用命令"></a>hexo 常用命令</h3><ol>
<li>hexo generate (hexo g)  生成一个存放静态文件的文件夹</li>
<li>hexo server (hexo s)  启动本地服务器预览博客内容</li>
<li>hexo deploy  当前目录文件下生成.deploy_git文件夹,并且把生成的静态文件上传到github上,需提前写好_config.yml</li>
<li>hexo new post 文章名 在根目录下的source/_posts下生成一个md文件,编辑此文件写文章</li>
<li>hexo clean  清除缓存文件 db.json 和 生成的静态文件夹 public</li>
</ol>
<hr>
<h3 id="常用组合命令"><a href="#常用组合命令" class="headerlink" title="常用组合命令"></a>常用组合命令</h3><p>hexo clean + hexo g + hexo s 本地预览博客文章<br>hexo clean + hexo g + hexo d 发布到github上<br>*hexo g/hexo d合并时候简写命令为 hexo g -d</p>
<hr>
<h3 id="hexo遇到的问题"><a href="#hexo遇到的问题" class="headerlink" title="hexo遇到的问题"></a>hexo遇到的问题</h3><p>1.全局安装后提示hexo不是命令提示符，解决办法:<br>①用git Bash 安装即可<br>②将安装包的位置添加到环境变量中</p>
<p>2.hexo d 提示 error deployer not found:github, 解决办法:<br>安装hexo-deployer-git // npm install hexo-deployer-git –save</p>
<h2 id="hexo使用了next主题"><a href="#hexo使用了next主题" class="headerlink" title="hexo使用了next主题"></a>hexo使用了next主题</h2><p>1.新增tags标签页<br>① hexo new page “tags”  新增一个tags页面,此时在source下生成一个tags文件夹,里面包含一个index.md<br>② 编辑刚才生成的这个index.md页面 新增 type: ‘tags’<br>③ 进入主题配置文件(_config.yml) 新增tags</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F;|| home</span><br><span class="line">  tags: &#x2F;tags&#x2F;|| tags</span><br></pre></td></tr></table></figure>
<hr>
<p>2.新增搜索功能<br>① hexo根目录下安装 npm install hexo-generator-searchdb –save<br>② 修改配置文件(theme/next/_config.yml)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true #默认为false</span><br></pre></td></tr></table></figure>
<p>③ 配置文件中新增</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post #搜索范围 post文章</span><br><span class="line">  format: html</span><br><span class="line">  limit: 1000 #搜索限制条数</span><br></pre></td></tr></table></figure>
<h3 id="折腾了一下next点击日志的时候跳转错误"><a href="#折腾了一下next点击日志的时候跳转错误" class="headerlink" title="折腾了一下next点击日志的时候跳转错误"></a>折腾了一下next点击日志的时候跳转错误</h3><p>版本更新一下后 点击日志突然报错 Cannot GET /archives/%7C%7C%20archive/<br>heox pagejson “version”: “5.1.4”<br>解决办法<br>在next主题下 sidebar.swig下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&#123;&#123; url_for(theme.menu.archives).split(&#39;||&#39;)[0] | trim &#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&#123;&#123; url_for(theme.menu.archives.split(&#39;||&#39;)[0]) | trim &#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>flex容器分配问题</title>
    <url>/2019/03/20/flex%E5%AE%B9%E5%99%A8%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="flex让自使用布局变得比较简单-本文记录一下flex如何分配空间"><a href="#flex让自使用布局变得比较简单-本文记录一下flex如何分配空间" class="headerlink" title="flex让自使用布局变得比较简单,本文记录一下flex如何分配空间"></a>flex让自使用布局变得比较简单,本文记录一下flex如何分配空间</h3><p><strong><em>本文所有情况只适用与flex-basis不为auto的情况,flex-basis为auto的时候,情况比较复杂</em></strong></p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex: 0 1 aut0;  &#x2F;&#x2F;默认值 等价于flex-grow,flex-shrink,flex-basis的简写,后两个参数可选</span><br></pre></td></tr></table></figure>
<p>flex-grow 定义项目的放大比例,默认为0,如果存在空间,也不放大<br>flex-shrink 定义项目的缩小比例,默认为1,如果空间不足,则缩小项目，为0则不缩小项目<br>其值我们统称为权重</p>
<h4 id="一-关于flex-grow的分配方式"><a href="#一-关于flex-grow的分配方式" class="headerlink" title="一.关于flex-grow的分配方式"></a>一.关于flex-grow的分配方式</h4><p><em>1.所有子项目flex-grow之和大于的1的情况</em><br>假定容器宽度为300px,其三个子项目宽度和flex-grow分别为 100px/1 150px/2 100px/3<br>此时剩余的可分配空间为 150px,那么每个子项目可得的空间如下</p>
<ul>
<li>150*1/6 = 25px</li>
<li>150*2/6 = 50px</li>
<li>150*3/6 = 75px</li>
</ul>
<p>也就是说剩余的150px的空间被三个子元素分成了6份(1+2+3/flex-grow相加之和),其子元素分别占有1/6,2/6,3/6<br>那么此时三个子元素的宽度为</p>
<ul>
<li>100 + 25 = 125px</li>
<li>150 + 50 = 200px</li>
<li>100 + 75 = 175px</li>
</ul>
<p><em>2.所有子项目flex-grow之和小于等于1的情况</em><br>假定容器宽度为300px,其三个子项目宽度和flex-grow分别为 100px/0.1 150px/0.2 100px/0.3<br>此时剩余的可分配空间为 150px,那么每个子项目可得的空间如下</p>
<ul>
<li>150*0.1/1 = 15px</li>
<li>150*0.2/1 = 30px</li>
<li>150*0.3/1 = 45px</li>
</ul>
<p>此时每个子元素的宽度为(容器仍有宽度未被分配,如果flex-grow相加等于1则空间正好分配完毕)</p>
<ul>
<li>100 + 15 = 115px</li>
<li>150 + 30 = 180px</li>
<li>100 + 45 = 145px</li>
</ul>
<h4 id="二-关于flex-shrink的分配方式"><a href="#二-关于flex-shrink的分配方式" class="headerlink" title="二.关于flex-shrink的分配方式"></a>二.关于flex-shrink的分配方式</h4><h5 id="子项目搜索除了受flex-shrink影响外-还会受到其自身宽度影响"><a href="#子项目搜索除了受flex-shrink影响外-还会受到其自身宽度影响" class="headerlink" title="子项目搜索除了受flex-shrink影响外,还会受到其自身宽度影响"></a>子项目搜索除了受flex-shrink影响外,还会受到其自身宽度影响</h5><p><em>1.所有子项目flex-shrink之和大于1的情况</em><br>假定容器宽度为500px,其三个子项目宽度和flex-shrink分别为 150px/1 200px/2 300px/3<br>此时溢出的宽度为 150 + 200 + 300 — 500 = 150px,那么每个子项目的收缩空间如下</p>
<ul>
<li>150 * 1 * 150/1450 = 15.5</li>
<li>150 * 2 * 200/1450 = 41.4</li>
<li>150 * 3 * 300/1450 = 93.1</li>
</ul>
<p>也就是说每个子元素的收缩空间为 溢出宽度 * flex-shrink * 子元素自身宽度 / 总权重(1 * 150 + 2 * 200 + 3 * 300)<br>总权重等于每个子元素flex-shrink * 自身宽度相加之和<br>那么此时的子元素的宽度为</p>
<ul>
<li>150 - 15.5 = 134.5</li>
<li>200 - 41.4 = 158.6</li>
<li>300 - 93.1 = 206.9</li>
</ul>
<p><em>1.所有子项目flex-shrink之和小于1的情况，唉,又麻烦了</em><br>假定容器宽度为500px,其三个子项目宽度和flex-shrink分别为 150px/0.1 200px/0.2 300px/0.3<br>此时溢出的宽度为 150 + 200 + 300 — 500 = 150px,那么每个子项目的收缩空间如下</p>
<ul>
<li>90 * 0.1 * 150/145 = 9.31</li>
<li>90 * 0.2 * 200/145 = 24.83</li>
<li>90 * 0.3 * 300/145 = 55.86<br>此时也就是说现在得收缩值不是溢出的150了,而是变成了150*(0.1+0.2+.03)/1 = 90,相当于只收缩了60%<br>所以此时的子元素宽度为</li>
<li>150 - 9.31 = 140.69</li>
<li>200 - 24.83 = 175.17</li>
<li>300 - 55.86 = 244.14</li>
</ul>
<p><strong><em>所有数值保留位数不精准,所以跟浏览器实际宽度会有一点出入</em></strong></p>
<h5 id="flex-grow-还受到max-width影响-flex-shrink-还受到min-width影响"><a href="#flex-grow-还受到max-width影响-flex-shrink-还受到min-width影响" class="headerlink" title="flex-grow 还受到max-width影响,flex-shrink 还受到min-width影响"></a>flex-grow 还受到max-width影响,flex-shrink 还受到min-width影响</h5><p><a href="https://zhuanlan.zhihu.com/p/24372279" target="_blank" rel="noopener">参考文章</a></p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用操作</title>
    <url>/2019/06/02/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>记录一下常用的git命令</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>创建一个本地仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone [git-url] [user-name]</span><br></pre></td></tr></table></figure>
<p>克隆一个远程仓库到本地,并且重命名 user-name可省,默认为远程仓库名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b [git-branch] [git-url] [user-name]</span><br></pre></td></tr></table></figure>
<p>从指定分支分支克隆远程仓库到本地,并且重命名 user-name可省</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote [git-params]</span><br></pre></td></tr></table></figure>
<p>列出远程仓库别名,默认会有(fetch/push)两条数据,这是因为git允许你为每个仓库添加不同的推送和获取连接,默认git-params缺省,此时只显示别名<br>git-params<br>-v 列出远程仓库别名和地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add [git-alias] [git-url]</span><br></pre></td></tr></table></figure>
<p>添加一个远程仓库, git-alias通常为origin </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote rm [git-alias]</span><br></pre></td></tr></table></figure>
<p>删除一个远程仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add . &#x2F; git add [file]</span><br></pre></td></tr></table></figure>
<p>添加文件到缓存区, .表示全部文件 file表示指定文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD [add-file]</span><br></pre></td></tr></table></figure>
<p>用于git add后撤销操作, add-flie省略则对上次add操作全部撤销</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status [git-params]</span><br></pre></td></tr></table></figure>
<p>查看工作目录和缓存区的状态<br>git-params<br>-s 简洁方式输出,只提示文件和状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &#39;&#39;</span><br></pre></td></tr></table></figure>
<p>提交至本地仓库,并备注</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset [git-params] [commit-id]</span><br></pre></td></tr></table></figure>
<p>撤销commit操作, git log 获取提交信息, 得到commit-id<br>git-params:<br>–mixed(默认) 撤销git commit, 撤销git add, 保留编辑器改动代码<br>–soft 撤销git commit, 不撤销git add, 保留编辑器改动代码<br>–hard 撤销git commit, 撤销git add, 删除编辑器改动代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --mixed HEAD^&#x2F;HEAD~1</span><br></pre></td></tr></table></figure>
<p>也是撤销操作 HEAD^(HEAD~1)表示上一版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull [git-alias] [online-git-branch]:[local-git-branch]</span><br></pre></td></tr></table></figure>
<p>将远程仓库git-alias下的online-git-branch远程分支拉取下去与local-git-branch本地分支合并, local-git-branch可省略,此时默认与当前分支合并</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push [git-alias] [local-git-branch] [online-git-branch]</span><br></pre></td></tr></table></figure>
<p>将local-git-branch本地分支上的内容推送到git-alias远程仓库上的online-git-branch分支<br>online-git-branch 可省,则表示将本地分支推送到与之存在追踪关系的远程分支(通常两者同名),如果该远程分支不存在,则会被新建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch [branch-name]</span><br></pre></td></tr></table></figure>
<p>创建本地分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout [branch-name]</span><br></pre></td></tr></table></figure>
<p>切换到指定分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b [branch-name]</span><br></pre></td></tr></table></figure>
<p>创建并切换到指定分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<p>查看所有分支,以及当前所处分支, -a省略则查看本地分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -D [branch-name]</span><br></pre></td></tr></table></figure>
<p>删除本地分支,(处于该分支时不能删除)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch [git-alias] [git-branch]</span><br></pre></td></tr></table></figure>
<p>从远程仓库git-alias拉取git-branch到本地仓库, git-branch省略,则拉取所有分支最新信息,包含新建分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge [git-alias&#x2F;git-branch]</span><br></pre></td></tr></table></figure>
<p>把git-alias/git-branch分支上的内容合并到当前分支上(分支写法有些特殊,同时包含远程仓库名/远程分支)</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>js跨域</title>
    <url>/2019/06/08/js%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<p>说起跨域,就要先从浏览器的同源策略说起,所谓同源策略就是指协议,域名,端口号都要相同,一项不同就产生了跨域问题。<br>同源策略作用大体分为两类: (1)限制接口 (2)限制查询DOM</p>
<a id="more"></a>
<p>解决跨域问题,常见的有已下几种方法:<br>一、jsonp<br>原理: 同源策略中,html中通过相应标签从不同域名中加载静态资源文件是被浏览器允许的,所以script/img/iframe标签是例外,不受同源策略限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">script.src &#x3D; &#39;***?id&#x3D;3&amp;callback&#x3D;callback&#39;;</span><br><span class="line">document.body.appendChild(script);</span><br><span class="line"></span><br><span class="line">function callback(res) &#123; console.log(res) &#125;</span><br></pre></td></tr></table></figure>
<p>缺点: 只支持GET请求<br>二、CORS(Cross-origin resource sharing) 跨域资源共享<br>CORS分为简单请求和非简单请求:<br>同时满足以下两个条件,就属于简单请求:<br>1.请求方法是下列之一: HEAD,GET,POST<br>2.HTTP头部信息不超过以下几种字段:<br>(1) Accept (2) Accept-Language (3) Content-Language (4) Last-Event-ID<br>(5) Content-Type 只限于application/x-www-form-urlencoded、multipart/form-data、text/plain</p>
<ul>
<li>简单请求会自动在请求头中加入Origin字段</li>
<li>非简单请求会先发起一次预检请求</li>
</ul>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">cors参考资料</a><br>三、Nginx代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 0000;</span><br><span class="line">  server_name localhost</span><br><span class="line">  location ^~ &#x2F;api &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;******</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 凡是localhost:0000&#x2F;api的所有接口都转发到http:&#x2F;&#x2F;******上处理</span><br></pre></td></tr></table></figure>

<p>四、document.domain + iframe<br>原理:通过设置document.domain为统一主域名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 现有abc.test.com下的a.html和xyz.test.com下的x.html</span><br><span class="line">&#x2F;&#x2F; a.html</span><br><span class="line">&lt;iframe src&#x3D;&quot;xyz.test.com&#x2F;x.html&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.domain &#x3D; &#39;test.com&#39;</span><br><span class="line">iframe.onload &#x3D; function()&#123; &#x2F;&#x2F;这里就可以查询x.html页面DOM &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F;x.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.domain &#x3D; &#39;test.com&#39;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>缺点:只支持主域名相同的<br>五、postMessage,H5新增API,可以安全地实现跨源通信</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer])</span><br></pre></td></tr></table></figure>
<p>otherWindow 其他窗口的引用,比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames<br>message 将要发送到其他 window的数据<br>targetOrigin 通过窗口的origin属性来指定哪些窗口能接收到消息事件,其值可以是字符串”*”（表示无限制）或者一个URI<br>transfer(可选) 是一串和message同时传递的Transferable对象.这些对象的所有权将被转移给消息的接收方,而发送一方将不再保有所有权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;a.test.com</span><br><span class="line">&lt;iframe name&#x3D;&quot;toiframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;b.example.com&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">&#x2F;&#x2F; 用于发送信息</span><br><span class="line">window.frames[&#39;toiframe&#39;].postMessage(&#39;from a.test.com&#39;,&#39;http:&#x2F;&#x2F;b.example.com&#39;)</span><br><span class="line">&#x2F;&#x2F; 用于接收信息</span><br><span class="line">window.addEventListener(&#39;message&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 检验消息来源</span><br><span class="line">  if(e.origin &#x3D;&#x3D;&#x3D; &#39;http:&#x2F;&#x2F;a.test.com&#39;)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;b.example.com</span><br><span class="line">window.addEventListener(&#39;message&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">  if(e.origin &#x3D;&#x3D;&#x3D; &#39;http:&#x2F;&#x2F;a.test.com&#39;)&#123;</span><br><span class="line">    &#x2F;&#x2F; 接收消息并回应</span><br><span class="line">    e.source.postMessage(&#39;from b.example.com answer&#39;, e.origin)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js防抖/节流</title>
    <url>/2019/06/10/js%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>简易版的防抖/节流,为了解决高频率触发事件引起的性能问题</p>
<a id="more"></a>
<p>一、防抖<br>规定时间内只执行最后一次(如5秒内没有函数调用请求,则执行该函数,否则继续等待5秒)<br>应用场景: 搜索联想</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(fn,delay) &#123;</span><br><span class="line">  let timer &#x3D; null</span><br><span class="line">  return function() &#123;</span><br><span class="line">    let args &#x3D; arguments</span><br><span class="line">    if(timer)&#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer &#x3D; setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">      fn.appl(this,args)</span><br><span class="line">    &#125;,delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、节流<br>函数在规定时间内只执行一次<br>应用场景: scroll事件 resize事件 touchmove事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(fn,wait) &#123;</span><br><span class="line">  let prevTime &#x3D; 0</span><br><span class="line">  return function() &#123;</span><br><span class="line">    let now &#x3D; new Date()</span><br><span class="line">    let args &#x3D; arguments</span><br><span class="line">    if( now-prevTime &gt; wait )&#123;</span><br><span class="line">      prevTime &#x3D; now</span><br><span class="line">      fn.apply(this,args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>存储那些事</title>
    <url>/2018/03/01/%E5%AD%98%E5%82%A8%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<p>记录一下浏览器存储的成员 cookie/localStorage/sessionStorage</p>
<a id="more"></a>
<p>一. cookie<br>document.cookie 可以获取当前所有cookie值, 每条cookie以键值对方式存在, 并且以分号和空格分离.</p>
<p>cookie格式如下:<br>① name=value(必须)cookie的名称和存储的值<br>② domain 对于哪个域名有效,默认为当前文档位置的路径的域名部分<br>③ path cookie路径,默认为当前文档位置的路径<br>④ expires cookie的过期时间,表示cookie何时应该被删除的时间戳,如果没有定义,cookie会在对话结束时过期<br>⑤ max-age cookie过期时间,单位是秒,优先级高于expires<br>⑥ httpOnly 告知浏览器不允许通过脚本document.cookie去更改这个值,同样这个值在document.cookie中也不可见<br>⑦ secure cookie只通过https协议传输</p>
<p>cookie满足同源策略,cookie大小在4K左右,一般不同浏览器下存储个数也不一样, chrome-53/safari-无限制<br>cookie每次都参与服务器请求,一般都由服务端设置</p>
<p>二. localStorage<br>localStore不参与服务端请求,一般大小在5M左右,只支持String格式存储(通常以Key/value的形式),需要手动进行删除<br>localStorage的方法:</p>
<ul>
<li>setItem(key, value) 新增一个项</li>
<li>getItem(key) 读取一个项</li>
<li>removeItem(key) 移除一个项</li>
<li>clear() 移除所有项</li>
</ul>
<p>三. sessionStorage<br>sessionStorage不参与服务端请求,一般大小在5M左右,只支持String格式存储(以Key/value的形式),关闭浏览器sessionStorage就会被清除<br><em>打开多个相同的URL的Tabs页面,会创建各自的sessionStorage</em><br>sessionStroage的方法:</p>
<ul>
<li>setItem(key, value) 新增一个项</li>
<li>getItem(key) 读取一个项</li>
<li>removeItem(key) 移除一个项</li>
<li>clear() 移除所有项</li>
</ul>
<p>总结:<br>1.生命周期<br>cookie设置过期时间, localStorage永久存储,除非手动清除, sessionStorage浏览器关闭的时候清除<br>2.数据存储大小<br>cookie-4K,浏览器不同,可设置的条数不同 localStorage/sessionStorage都是5M<br>3.与服务器通信<br>cookie每次都会携带在header中, localStorage/sessionStorage不参与服务端通信</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>从输入url到页面展示都发生了啥</title>
    <url>/2019/04/07/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>set/map的区别</title>
    <url>/2019/06/24/set-map%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>Set/WeakSet/Map/WeakMap 傻傻分不清楚<br>Set和Map是ES6中新定义的数据结构,记录一下</p>
<a id="more"></a>

<h3 id="Set-对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用"><a href="#Set-对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用" class="headerlink" title="Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用"></a>Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Set([iterable]);</span><br></pre></td></tr></table></figure>
<p>如果传递一个可迭代对象,它的所有元素将不重复地被添加到新的Set中. 如果不指定此参数或其值为null,则新的Set为空</p>
<blockquote>
<p>目前所有的内置可迭代对象如下：String、Array、TypedArray、Map 和 Set  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="noopener">MDN</a></p>
</blockquote>
<p>向Set加入值的时候,不会发生类型转换,set内NaN和NaN是相等的<br>set的实例属性: size 返回set对象值的个数</p>
<p>set的方法:</p>
<ul>
<li>add(value) 在Set对象尾部添加一个元素,返回该Set对象</li>
<li>clear() 移除Set对象内的所有元素</li>
<li>delete(value) 移除Set的中与这个值相等的元素</li>
<li>has(value) 返回一个布尔值,表示该值在Set中存在与否</li>
<li>keys()/values() 返回一个新的迭代器对象,该对象包含Set对象中的按插入顺序排列的所有元素的值</li>
<li>entries() 返回一个新的迭代器对象,该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组.为了使这个方法和Map对象保持相似,每个值的键和值相等</li>
</ul>
<h4 id="WeakSet-对象允许你将弱保持对象存储在一个集合中"><a href="#WeakSet-对象允许你将弱保持对象存储在一个集合中" class="headerlink" title="WeakSet 对象允许你将弱保持对象存储在一个集合中"></a>WeakSet 对象允许你将弱保持对象存储在一个集合中</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new WeakSet([iterable]);</span><br></pre></td></tr></table></figure>
<p>如果传入一个可迭代对象作为参数,则该对象的所有迭代值都会被自动添加进生成的WeakSet对象中, null 被认为是 undefined</p>
<p>weakset的方法</p>
<ul>
<li>add(value)  在该 WeakSet 对象中添加一个新元素 value</li>
<li>delete(value) 从该 WeakSet 对象中删除 value 这个元素</li>
<li>has(value) 返回一个布尔值,表示给定的值 value 是否存在于这个 WeakSet 中</li>
</ul>
<h3 id="set与weakset的区别"><a href="#set与weakset的区别" class="headerlink" title="set与weakset的区别"></a>set与weakset的区别</h3><ol>
<li>set可以存放任何类型的值,而weakset只能存放对象引用</li>
<li>set可以循环遍历,而weakset不可以遍历(WeakSet 对象中储存的对象值都是被弱引用的,垃圾回收机制不考虑 WeakSet 对该对象的应用,如果没有其他的变量或属性引用这个对象值,则这个对象将会被垃圾回收掉,不考虑该对象还存在于 WeakSet 中)</li>
</ol>
<hr>
<h3 id="Map对象保存键值对-并且能够记住键的原始插入顺序-任何值-对象或者原始值-都可以作为一个键或一个值"><a href="#Map对象保存键值对-并且能够记住键的原始插入顺序-任何值-对象或者原始值-都可以作为一个键或一个值" class="headerlink" title="Map对象保存键值对,并且能够记住键的原始插入顺序,任何值(对象或者原始值) 都可以作为一个键或一个值"></a>Map对象保存键值对,并且能够记住键的原始插入顺序,任何值(对象或者原始值) 都可以作为一个键或一个值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Map()</span><br></pre></td></tr></table></figure>
<p>Map中只存在唯一的键(NaN在Map中被认为是相等的)</p>
<h4 id="Map和object区别"><a href="#Map和object区别" class="headerlink" title="Map和object区别"></a>Map和object区别</h4><ol>
<li>Map默认不包含任何键, Object有原型链,原型链上的键名可能是自己设置的键名冲突</li>
<li>Map的键可以是任何类型, Object的键只能是 Sting / Symbol 类型</li>
<li>Map中的键是有序的,按插入顺序返回, Object的键无序</li>
<li>Map的键值对个数通过size直接获取, Object需要手动计算</li>
<li>频繁的操作下Map表现更好</li>
<li>Map可以直接迭代, Object需要获取它的键然后才能迭代</li>
</ol>
<p>map的方法</p>
<ul>
<li>set(key, value) 设置Map对象中键的值,返回该Map对象</li>
<li>delete(key) 如果 Map 对象中存在该元素,则移除它并返回true;否则如果该元素不存在则返回false</li>
<li>get(key) 返回键对应的值,如果不存在,则返回undefined</li>
<li>has(key) 返回一个布尔值,表示Map实例是否包含键对应的值</li>
<li>keys() 返回一个新的Iterator对象,它按插入顺序包含了Map对象中每个元素的<em>键</em></li>
<li>values() 返回一个新的Iterator对象,它按插入顺序包含了Map对象中每个元素的<em>值</em></li>
<li>clear() 移除Map对象的所有键/值对</li>
</ul>
<h4 id="WeakMap-对象是一组键-值对的集合-其中的键是弱引用的-其键必须是对象-而值可以是任意的"><a href="#WeakMap-对象是一组键-值对的集合-其中的键是弱引用的-其键必须是对象-而值可以是任意的" class="headerlink" title="WeakMap 对象是一组键/值对的集合,其中的键是弱引用的. 其键必须是对象,而值可以是任意的"></a>WeakMap 对象是一组键/值对的集合,其中的键是弱引用的. 其键必须是对象,而值可以是任意的</h4><p>weakMap的方法: </p>
<ul>
<li>set(key, value) 在WeakMap中设置一组key关联对象,返回这个 WeakMap对象</li>
<li>get(key) 返回key关联对象,或者undefined(没有key关联对象时)</li>
<li>has(key) 根据是否有key关联对象返回一个Boolean值</li>
<li>delete(key) 移除key的关联对象</li>
</ul>
<h3 id="Map和WeakMap的区别"><a href="#Map和WeakMap的区别" class="headerlink" title="Map和WeakMap的区别"></a>Map和WeakMap的区别</h3><ol>
<li>Map的键可以是任何类型,WeakMap的键只能是对象</li>
<li>Map可以遍历,WeakMap不可以遍历</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Set</p>
<ul>
<li>成员唯一,可以是任何类型,无序</li>
<li>只有值没有键,可遍历</li>
</ul>
<p>WeakSet</p>
<ul>
<li>成员只能是对象</li>
<li>成员都是弱引用,可被垃圾机制回收,不可遍历</li>
</ul>
<p>Map</p>
<ul>
<li>按插入顺序存放键值对,键可以是任何类型</li>
<li>可遍历</li>
</ul>
<p>WebkMap</p>
<ul>
<li>只能对象做为键(null除外),不可遍历</li>
<li>键被垃圾回收后,键无效</li>
</ul>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>改变this指向的三剑客</title>
    <url>/2018/06/04/%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91%E7%9A%84%E4%B8%89%E5%89%91%E5%AE%A2/</url>
    <content><![CDATA[<p>记录一下能改变this指向的三剑客,他们就是call() / apply() / bind()<br>call()/apply()作用一致,只是call接受的是一个参数列表,apply接受一个包含多个参数的数组,bind则创建一个新的函数</p>
<a id="more"></a>
<p>一. call()方法 使用一个指定的 this 值和单独给出的一个或多个参数来调用一个<em>函数</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">funtion.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p>thisArg可选参数, 在function运行时使用的this值. 非严格模式下,指定null或undefined则自动替换成全局对象, 如果不指定thisArg,this的值会绑定为全局对象,严格模式下this的值是undefined</p>
<p>举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var apple &#x3D; &#123;</span><br><span class="line">  color: &#39;red&#39;,</span><br><span class="line">  say: function() &#123;</span><br><span class="line">    return &#96;color is $&#123;this.color&#125;&#96;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var banana &#x3D; &#123;</span><br><span class="line">  color: &#39;yellow&#39;</span><br><span class="line">&#125;</span><br><span class="line">apple.say.call(banana) &#x2F;&#x2F; color is yellow</span><br></pre></td></tr></table></figure>
<p>banana没有say方法,我们可以去向apple借用一下,再比如,取出数组中的最大值,我们可以用一个简单的方法,借用Math.max方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var numbers &#x3D; [5,8,90]</span><br><span class="line">Math.max.call(numbers,...numbers) &#x2F;&#x2F; 90</span><br></pre></td></tr></table></figure>
<p>其实说白了, call他自己做了三件事</p>
<ol>
<li>将函数设置为传入对象的属性</li>
<li>然后执行这个函数</li>
<li>执行完成后,删除这个新增属性</li>
</ol>
<p>那我们就可以实现一个自己的call函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.mycall &#x3D; function(context&#x3D;window)&#123;</span><br><span class="line">  context.fn &#x3D; this &#x2F;&#x2F;将函数设置为传入对象的属性</span><br><span class="line">  let args &#x3D; [...arguments].slice(1) &#x2F;&#x2F;抽离出传入的参数</span><br><span class="line">  let result &#x3D; context.fn(...args) &#x2F;&#x2F; 执行这个函数</span><br><span class="line">  delete context.fn &#x2F;&#x2F; 删除这个属性</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES5版相对复杂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.mycall &#x3D; function(context)&#123;</span><br><span class="line">  context &#x3D; context || window</span><br><span class="line">  var args &#x3D; []</span><br><span class="line">  for(var i&#x3D;0; i&lt;arguments.length; i++)&#123;</span><br><span class="line">    args.push(&#39;arguments[&#39; + i + &#39;]&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  var argstr &#x3D; args.join(&#39;,&#39;)</span><br><span class="line">  context.fn &#x3D; this</span><br><span class="line">  &#x2F;&#x2F; ES5 由于无法通过解构的形式传入参数，只能通过字符串拼接然后再通过eval来执行</span><br><span class="line">  var res &#x3D;  eval(&#39;context.fn(&#39; + argstr + &#39;)&#39;)</span><br><span class="line">  delete context.fn</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eval()函数可计算某个字符串,并执行其中的的JavaScript代码<strong>不建议使用</strong><br><em>需要注意的点</em></p>
<ul>
<li>如果string参数不是原始字符串,那么该方法将不作任何改变地返回</li>
<li>试图覆盖eval属性或把eval()方法赋予另一个属性,并通过该属性调用它,则抛出一个EvalError异常</li>
<li>参数中没有合法的表达式和语句,则抛出SyntaxError异常</li>
<li>传递给eval()的Javascript代码生成了一个异常,eval()将把该异常传递给调用者</li>
</ul>
<p>二、apply()方法与call()功能一致<br>写一个自己的apply方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.myapply &#x3D; function(context &#x3D; window) &#123;</span><br><span class="line">  context.fn &#x3D; this</span><br><span class="line">  let result;</span><br><span class="line">  if(arguments[1]) &#123; &#x2F;&#x2F; 判断是否有第二个参数</span><br><span class="line">    result &#x3D; context.fn(...arguments[1])</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result &#x3D; context.fn()</span><br><span class="line">  &#125;</span><br><span class="line">  delete context.fn</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES5版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.myapply &#x3D; function()&#123;</span><br><span class="line">  context &#x3D; context || window; </span><br><span class="line">  context.fn &#x3D; this;</span><br><span class="line">  var result;</span><br><span class="line">  &#x2F;&#x2F; 判断是否存在第二个参数</span><br><span class="line">  if (arguments[1]) &#123;</span><br><span class="line">    result &#x3D; context.fn();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    var args &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 0, len &#x3D; arguments[1].length; i &lt; len; i++) &#123;</span><br><span class="line">      args.push(&#39;arguments[1][&#39; + i + &#39;]&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    result &#x3D; eval(&#39;context.fn(&#39; + args + &#39;)&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  delete context.fn</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三、bind()方法创建一个新的函数,在bind()被调用时,这个新函数的this被指定为bind()的第一个参数,而其余参数将作为新函数的参数,供调用时使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function.bind(thisArg, arg1, arg2)</span><br></pre></td></tr></table></figure>
<p>thisArg 调用绑定函数时作为this参数传递给目标函数的值;如果使用new运算符构造绑定函数,则忽略该值<br>如果bind函数的参数列表为空,或者thisArg是null或undefined,执行作用域的this将被视为新函数的thisArg</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var number &#x3D; 9</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  number: 8,</span><br><span class="line">  getNumber: function()&#123;</span><br><span class="line">    return &#96;number:$&#123;this.number&#125;&#96;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getNumber() &#x2F;&#x2F; number:8</span><br><span class="line">var newGet &#x3D; obj.getNumber</span><br><span class="line">newGet() &#x2F;&#x2F;number:9  因为函数是在全局作用域中调用的</span><br><span class="line">var bindGet &#x3D; newGet.bind(obj)</span><br><span class="line">bindGet() &#x2F;&#x2F;number:8 通过bind改变this的值</span><br><span class="line">var emptyBind &#x3D; newGet.bind() </span><br><span class="line">emptyBind() &#x2F;&#x2F;number:9 因为bind参数列表为空,emptyBind在全局作用域中调用,所以this指向window thisArg为null和undefined时同理</span><br></pre></td></tr></table></figure>
<p>bind另一个用法是可以使一个函数拥有预设的初始参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function list() &#123;</span><br><span class="line">  return Array.prototype.slice.call(arguments)</span><br><span class="line">&#125;</span><br><span class="line">var newlist &#x3D; list.bind(null,37)</span><br><span class="line">newlist(1,2,3) &#x2F;&#x2F; [37,1,2,3]</span><br></pre></td></tr></table></figure>
<p>手写一个bind方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.mybind &#x3D; function(context)&#123;</span><br><span class="line">  let that &#x3D; this;</span><br><span class="line">  &#x2F;&#x2F; mybind绑定的时候传入的第二个参数</span><br><span class="line">  let args1 &#x3D; Array.prototype.slice.call(arguments,1);</span><br><span class="line">  let bindFn &#x3D; function()&#123;</span><br><span class="line">    let args2 &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">    &#x2F;&#x2F; 判断一下是否用new创建了一个新实例</span><br><span class="line">    return that.apply(this instanceof bindFn?this:context,args1.concat(args2)); </span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 使用空函数继承原型链</span><br><span class="line">  let Fn &#x3D; function()&#123;&#125;;</span><br><span class="line">  Fn.prototype &#x3D; this.prototype;</span><br><span class="line">  bindFn.prototype &#x3D; new Fn();</span><br><span class="line">  return bindFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
